---
title: "ゲームにおける実践的なレイマーチング ― ラスタライズ方式と併用"
emoji: "🌌"
type: "tech"
topics:
  - "gamedev"
  - "directx12"
  - "raytracing"
published: true
published_at: "2025-12-03 15:04"
---

[KMC Advent Calender 2025](https://adventar.org/calendars/12258) の 4 日目の記事です。
本記事ではラスタライズ方式とレイマーチング方式を組み合わせた描画について、実際に自作エンジンでR&Dした内容を紹介します。
ゲームのグラフィック技術についてまだまだ勉強中であり、本業の方からすれば拙い内容となっているかもしれませんが、大目に見ていただけると幸いです。

------

## 1. ポリゴンを用いた現代の3D描画手法

この記事を読んでいる方であれば、「ポリゴン」という言葉を一度は耳にしたことがあるのではないでしょうか。本記事では、三角形を基本単位とする 3D 形状の構成要素をポリゴンと呼ぶことにします。現代の 3D 表現では、キャラクターや背景を含むほぼ全てのオブジェクトが、三角形ポリゴンの集合として表現されています。各頂点には法線ベクトルやテクスチャ座標といった情報が付与され、これにより立体的な質感や陰影表現が可能になります。

例として、以下のゲームのポリゴンを確認してみましょう。ポリゴンの三角形を塗りつぶさず、ワイヤーフレームで表示してみます。

![](https://storage.googleapis.com/zenn-user-upload/00d2d2b01cb7-20251203.png)

シーンをワイヤーフレーム表示にしてみると、全オブジェクトが骨組みだけになってスカスカの画面になりました。このように、シーン内の3Dモデルはもちろんのこと、UIといった2D要素も全て三角形の集合体で描画されていることが分かります。

![](https://storage.googleapis.com/zenn-user-upload/1f70eebe7dfd-20251203.png)

これらのポリゴンを実際に画面へ描画する手法は主に2つあります。**ラスタライズ方式**と**レイトレーシング方式**です。従来の 3D ゲームではラスタライズ方式が圧倒的に主流であり、レイトレーシングは映像制作といったオフラインレンダリングでの使用に留まっている傾向がありました。しかし近年は GPU の高性能化に伴い、リアルタイム 3D ゲームにおいてもレイトレーシングが徐々に普及しつつあるようです。

ラスタライズ方式は、シーン中の三角形をスクリーン平面へ投影し、2D に投影された三角形領域を高速に塗りつぶす方式です。3D ゲーム黎明期から使われてきた成熟した手法であり、GPU によるハードウェアアクセラレーションが非常に充実しているため、現在でも多くのゲームに採用されています。上記のスクリーンショットもラスタライズ方式で描いています。

一方でレイトレーシング方式は、画面上の各ピクセルからレイ (光線) を発射し、シーンのポリゴンと交差した点を基に色を決定する手法です。計算量は大きいものの、反射や屈折、影、間接光などの効果を物理的に整合した形で扱えるため、ラスタライズ方式よりも自然で写実的な光の表現が可能になります。


------



## 2. 3Dオブジェクトのポリゴン数

さて、ゲームにおける3Dオブジェクトは、多数のポリゴンによって構成されています。例えば、Blender ユーザーにとってはお馴染みのお猿さんモデル (Suzanne) はポリゴン数が507です。

![](https://storage.googleapis.com/zenn-user-upload/fac9ae87af92-20251203.png)

ポリゴン数が増えるほど GPU の処理負荷も大きくなるため、開発現場ではオブジェクトごとのポリゴン数を意識しながらモデリングを行っているようです。

小さな小物であれば数千ポリゴン以内に収まりますが、造形が複雑になるほど必要なポリゴン数は自然と増大していきます。また、ターゲットとするプラットフォームによって許容されるポリゴン数は大きく異なります。たとえば、**モバイル向けのキャラクターモデルは数万ポリゴン程度**が一般的とされる一方、**ハイエンドゲームでは数十万ポリゴン規模**の非常に精密なモデル[^ac6]が採用されることもあります。大手有名タイトルであっても、作品によっては3Dモデルを公開していたり、開発記事の中で大まかなポリゴン数が紹介されていることがあり、そうした資料を参照することで市販ゲームのおおよそのポリゴン数を把握することができます。

では、突然ですがここでクイズです。次に示すモデルのポリゴン数はどれくらいだと思いますか。

![](https://storage.googleapis.com/zenn-user-upload/abcd1aa8f60b-20251203.png)

なかなか複雑な図形なので、大量にポリゴンがある気がしますよね。しかし、このモデルはなんと**ポリゴン数 0** なのです。

描画結果としてオブジェクトが存在しているのにポリゴンが一つも存在しないとは、にわかには信じがたい話かもしれません。

というのも、実はこのモデルはポリゴンと全く違うデータ表現で出来ているのです。それは、**SDF (Signed Distance Field)** と呼ばれる、数式ベースの3D形状表現です。

------

## 3. SDF（Signed Distance Field）とは何か

SDF とは 「物体の表面からの距離を返す関数」です。物体の外側は正の値ですが、物体の内部は負の値となります。例えば、中心点 c、半径 r の球体の SDF は次の式で表せます:

$$ f(\mathbf{p}) = \|\mathbf{p} - \mathbf{c}\| - r $$


これは以下のような擬似コードで表せます。

```c
float sdfSphere(float3 p)
{
	return length(p - c) - r;
}
```



以下の図では半径2の球のSDFを表しています。簡単のため離散的な2D画像となっていますが、実際は3次元空間全体に広がった連続的なスカラー場です。

![](https://storage.googleapis.com/zenn-user-upload/7a7d8fdacc0c-20251203.png)

このように、3Dモデルをポリゴンで表す手法とは異なり、SDFを用いることで物体を数式的に定義出来ます。

SDFの特徴として、関数を組み合わせることで多彩な表現ができることが挙げられます。SDFの和、差、差分を組み合わせて新しい形状を作るCSG (Constructive Solid Geometry)、形状の境界を溶かすように自然に合体させる smooth-min、万華鏡のようなシーンを作る polar-modといったように、様々なテクニックを用いることで多彩なSDFを表現できます。

SDFで定義されたオブジェクトを描画する手法として**レイマーチング**と呼ばれる手法があります。レイトレーシングという言葉を聞いたことがある人は多いと思いますが、レイトレーシングは光線とポリゴンとの厳密な交差判定を行う描画方式である一方、レイマーチングは主に SDFを用いて光線に沿って距離を積み上げながら衝突点を求める手法です。

ここでポリゴンとSDFの違いを整理してみましょう。

|      観点      | ポリゴン                        | SDF              |
| :------------: | ------------------------------- | ---------------- |
|  主なレンダリング手法  | ラスタライズ / レイトレーシング | レイマーチング   |
|    表現形式    | 三角形の配列                    | 関数             |
| 近距離の見え方 | ポリゴンの継ぎ目が見える        | 常に滑らか       |
|      変形      | 面倒                            | 簡単             |
|    オブジェクト同士の衝突判定    | 必ず可能                        | 困難な場合がある |

このように、ポリゴン、SDFそれぞれで長所と短所があります。ポリゴンモデルは形状を三角形メッシュとして離散化する都合上、あらゆるモデルを扱いやすい一方で、オリジナルの滑らかな形状を離散化する過程でどうしても情報が失われてしまいます。 一方 SDF は、形状を解析的な距離関数として定義するため、理論上は元の形状を完全な精度で記述でき、情報を欠落なく表現できる点が大きな特徴です。先程のようなフラクタル図形もポリゴンでは膨大なデータ量となってしまいますが、SDFならシンプルな表現で記述出来ます。一応補足ですが、SDFはレイマーチングだけでなく、フォントのレンダリングといった2D描画でも使われることがあります。ビットマップ画像からSDFを生成し、フォントをどれだけ拡大しても輪郭がギザギザにならず滑らかにレンダリング出来ます。

上記の表に加え、ゲームでは描画パフォーマンスにも違いがあります。ポリゴンではハードウェアレベルでレンダリングがサポートされており、レイマーチングと比較してより高速にシーンを画面上に描画出来ることが多いです。とはいえ、同じシーンを描画したいときに必ずしもポリゴンのほうがパフォーマンスが優れているとは限らないという点には注意です。例えば、球を一定間隔で遠方まで大量に床に配置した以下のシーンを描画することを考えましょう。

![](https://storage.googleapis.com/zenn-user-upload/59c82a106d99-20251203.png)

もしこのシーンをポリゴンを用いてラスタライズ方式で描画する場合、球体の数が増えれば増えるほどレンダリングのコストが増えます。今回の場合、地平線の先まで球体がぎっしりと敷き詰まったシーンであり、その描画コストはかなりのものになりそうです。

それに対して、SDFを用いてレイマーチングする場合について考えてみましょう。このシーンのSDFは以下のような擬似コードで表現できます。

```c
float sdfSphereRepeat(float3 p)
{
    // 折り返し
    p.xz = frac(p.xz / (r * 2)) * (r * 2); // <-- 折り返し

	return length(p) - r;
}
```

先程の `sdfSphere` に `p.xz = frac(p.xz / (r * 2)) * (r * 2);` という一行だけ追加しました。これで p をXZ平面上で周期 `(r * 2)` の範囲に折り返しています。たったこれだけで、球体をXZ平面上で無限に複製することが出来ます。SDF自体は球体一つの場合と殆ど変わらず、このような大量の球体をレイマーチングすることは球体一つをレイマーチングする場合とあまり変わらない計算コストとなります。

このように、SDFは**フラクタルや無限に規則的な構造に強く**、ポリゴンでは表現が難しい世界もSDFなら簡単に低コストで作れる場合があります。

------

## 4. レイマーチングをゲームで使いたい

さて、レイマーチングによる映像表現はよく知られた技法です。実際、Shadertoy[^shadertoy] といったシェーダー共有サービスを覗いてみると、毎日のように独創的で高度なシェーダーが投稿されています。

しかしながら、実際のゲームタイトルでの採用例はあまり多くないように見えます。理由は多くあると思いますが、一番の壁としてはやはり描画パフォーマンスの問題でしょうか。シンプルなシーンでも 1 ピクセルごとに何十～何百回もSDFを評価する必要があり、ハードウェアレベルで最適化されたラスタライズ方式と比較して多くの場面で圧倒的にコストが高くなります。それに加えて、SDFで幾何的な形状は作れるとは言え、重厚感たっぷりの戦闘機や感情豊かな可愛いキャラクターは作成しづらく、ゲームのアートデザイン的にも取り入れづらそうです。

とはいえ、レイマーチングを使うことで、短時間で複雑な背景や幻想的な構造物を生成できる長所は非常に魅力的です。私自身モデリングにあんまり慣れていないのですが、そんな私でも、SDFならそれなりの品質のオブジェクトをモデリングツールを一切用いることなく定義する事ができます。

ならば、やはりゲーム開発でもSDFで作ったオブジェクトを使いたいところです。そこで、ラスタライズ方式でキャラクターや主要オブジェクトを作り込みつつ、背景部分をレイマーチングで手軽に生成できれば、開発効率を上げつつ独特の世界観を構築できるのではないでしょうか。ということで、実際に自作エンジンにレイマーチングを統合し、このハイブリッド手法を実装してみることにしました。

------

## 5. ラスタライズ方式とレイマーチングのハイブリッド描画

今回は DirectX 12 をバックエンドとした自作エンジンのディファードレンダリングにおいてレイマーチングによる背景描画を取り入れ、そのうえでレースゲームのデモを作りました。このデモでは、シーン上のコースやレースマシンといったコライダーのついたオブジェクトはポリゴンで表現し、当たり判定無しの背景部分をレイマーチングで描画しています。

具体的な手順について説明します。まず、ラスタライズ方式でシャドウマップやディファードレンダリング用の GBuffer を作ります。GBuffer にはアルベドや法線情報の他に、深度やカメラからの距離といった情報も格納します。

![](https://storage.googleapis.com/zenn-user-upload/658fccc40d25-20251203.png)

そのうえで、GBuffer 統合段階において次のような処理を行います。まずはレイマーチングを行い、SDFのヒット点を求めます。レイマーチングに用いるレイの方向や視点を求める必要がありますが、ラスタライズ段階で用いたカメラ情報と同一になるように正規化デバイス座標系から計算する必要があります。レイマーチングの結果をもとに、SDFのヒット点のワールド座標、ラスタライズ段階で書き込みが発生したワールド座標どちらが手前にあるかを比べます。よりカメラに近いほうを採用してライティング計算を行います。

```c
// GBuffer に格納されたカメラ距離
float distanceLimit = g_viewDistanceBuffer[pixelCoord];

// distanceLimit までレイマーチングする
RayMarchResult hit = rayMarch( ... );

if (hit.viewDistance < distanceLimit) {
	// レイマーチングで SDF とヒットした
	// --> レイマーチング結果を使用
    albedo = hit.color;
	...
} else {
	// レイマーチングで SDF とヒット無し
    // --> GBuffer の値を使用
    albedo = g_albedoBuffer[pixelCoord].rgb;
    ...
}

// 適当なライティング計算
finalColor = lighting(albedo, ... );
```

このようにして、ひとまずラスタライズ方式とレイマーチングをハイブリッドさせた描画が実現できました。

------

## 6. 高速化: FSRを利用したアップスケーリング

というわけで、実際に動かしてみました。まずはNVIDIA GeForce RTX 3080が載っている開発PCで動作させたところ、余裕で安定した60FPS動作が出来ました。しかし、手元にあった Intel Core i5 (11th) 搭載のノートPCの内蔵GPUで動作させてみたところ、残念ながら5~20FPSしか出ない結果となりました。この状況を詳しく調査するため、プロファイリングツール PIX を用いて確認してみましょう。すると、以下のような結果となりました。

![](https://storage.googleapis.com/zenn-user-upload/8f2f5ca076f7-20251203.png)

赤枠で囲った部分が今回のレイマーチング部分となっています。どうやら、これだけで 40 ms もかかっているではありませんか。とても実用的とは言えませんね。

11世代 i5 の iGPU ではゲームを全然快適に遊べないということが分かりました。低スペック環境を切り捨てることは簡単ですが、折角ならより多くの環境でゲームを動かしたいですね。ということで、11世代 i5 でも60FPS動作を目指していきたいと思います。

ではどうやってフレームレートを改善させるかという話ですが、やはりレイマーチングの計算回数を減らすことが課題となってきます。つまるところ、解像度を下げてしまうというのが最も手っ取り早い解決策となります。

とはいえ、折角レイマーチングで魅力的なアートを描いているというのに、その品質を下げてしまうというのは心苦しい思いがします。こうした状況で有力な切り札があります。そう、それは**超解像度技術**です。超解像度技術は「低解像度で絵を描いておいて、それを良さげなアルゴリズムやAIで解像度を上げよう」という思想の技法で、描画コストを抑えつつ見た目の品質を維持することが出来ます。あるいは元の解像度よりも高品質になる場面もあるようです。レイトレーシング標準の次世代ゲームにおいて、AIアップスケーリングは欠かせない技術とも言われており、NVIDIA はDLSS、AMDはFSR、Intel はXeSS といったように主要半導体メーカーは挙って開発しています (一応補足ですが、この文脈におけるAIは「事前学習済みのCNNモデルを使って、元の情報を推測補完する」というニュアンスで使っています)。また、最近ではSIEがPSSRを搭載したPS5 Proを発売しましたね。マーク・サーニーさんの PS5 Pro 技術解説動画[^ps5-pro]が公開されているのですが、非常に興味深い内容となっているので視聴してみると面白いと思います。

閑話休題として、今回導入するアップスケーリングを考えます。しかしながら、オープンソースで一般開発者が自由に利用できる超解像度技術はAMDのFSRのみとなっており、選択肢は実質一つです。現在FSRはFSR 4までバージョンがありますが、今回は**FSR 1[^fsr1]** を選択します。FSR 1は昔ながらの非AI空間アップスケーラです。なぜ一番古いバージョンのFSRにするかという話ですが、時間方向アップスケーラーであるFSR 2 以降はモーションベクトルを必要としており、レイマーチングには適さないという事情があります。モーションベクトルというのは、各ピクセルの情報が次のフレームでどこに移動するかということを表現したデータなのですが、レイマーチングでモーフィングなどは画素ごとのモーションベクトルの計算が困難もしくは不可能です。そういうわけで、モーションベクトルを必要としない、空間アップスケーラーであるFSR 1 を使っていきます。FSR 1 はかなり特殊な形態のヘッダオンリライブラリとして提供されているのですが、既存のレンダリングパスでポストプロセス的に用いることが出来るので導入が容易です。実際 Nintendo Switch 2 の現状を見ると、目玉である DLSS よりも FSR 採用のタイトルが多いことからもFSR の扱いやすさがよく分かります。

FSR 1を実行する前に、適当なアンチエイリアスを適用するとより良い結果が得られるようです。『ドンキーコングバナンザ』では**SMAA+FSR 1** が使われているようです。これに倣って私も SMAAを導入しようと思ったのですが、github 上で公開されているSMAA[^smaa]の最終更新が12年前であり、DirectX 10 以前のかなり古いシェーダーモデルで書かれたコードだったので DirectX 12 に導入することが困難なように見受けられました。開発期間においてアンチエイリアス部分にかける時間があまりなかったので、やむを得ず今回は生成AIに作らせたSMAA風の謎アンチエイリアスを使うことにしました。

さて、実際にFSR 1を導入してみた結果がこちらになります。順に解像度1.0倍(1080p)、0.8倍(864p)、0.4倍(432p)からFSR 1のアップスケーリングを行っています。864p、432pは解像度のピクセル数が縦横ともに32の倍数となっておりFSR 1で扱いやすいです。

![](https://storage.googleapis.com/zenn-user-upload/c2f613b73079-20251203.png)

![](https://storage.googleapis.com/zenn-user-upload/0bdefb54ab1d-20251203.png)

![](https://storage.googleapis.com/zenn-user-upload/833b671c97ef-20251203.png)

どうでしょうか。432p というかなり低い解像度でも意外と画質の劣化が少ないように思えませんか。その上、432pではレイマーチングコストが大幅に減少し、11世代 i5 の iGPU でも安定して60FPSで動作しました。FSRにより、画質の劣化を抑えつつ安定したフレームレートで動作させることが出来ました。

簡易的なプロファイリングを行ったところ、画面上でラスタライズで描画した部分の占める割合が大きければレイマーチングのコストが小さくなり、864p、場合によっては1080pでも60FPSで動作すると分かりました。場所によってレイマーチングのコストが変化するので、ゲームではレイマーチングの負荷に応じて動的に解像度を変化させることにしました。解像度の変更はGBuffer のレンダーターゲットのビューポートを変更するだけで済みます。

![](https://storage.googleapis.com/zenn-user-upload/32dfe931e440-20251203.png)

ここで興味深いのは、**アップスケーリングによる画質の逆転現象**が起きている部分があることです。以下の画像をよく見てください。

![](https://storage.googleapis.com/zenn-user-upload/1c29e4ae17c0-20251203.png)

864p よりも 432p のほうがハートのテクスチャのジャギーが解消されて明らかに滑らかになっているように見えます。ハートのテクスチャ解像度が小さいためエッジケースになっているかもしれませんが、より低解像度で描画したはずの場合のほうが画質が上がる結果となったのは非常に興味深いですね。



------

## 7. さらに高速化: 共有メモリを使った近似レイマーチング

FSR 1の導入により60 FPS動作を実現することが出来ました。ここからさらに、レイマーチング自体を改良してみることをやってみます。レイマーチングをコンピュートシェーダーで実装して共有メモリの強みを活かしてみましょう。共有メモリを使えばスレッドグループ内全体で情報を共有することが出来ます。

一般的なレイマーチングでは、各ピクセルのレイが完全に独立しており、全てのピクセルがゼロからSDF空間を探索します。このとき、隣接ピクセル同士から飛ばしたレイは同じ物体付近に到達する可能性が高いはずです。更には、上下左右の周辺ピクセルから飛ばしたレイがすべて同じ物体に到達している場合、その中央に位置するピクセルのレイも、その近傍で到達する可能性が高いと思われます。なので、このアイデアを取り入れることで高速にレイマーチングが出来るのではないかと思いやってみました。

![](https://storage.googleapis.com/zenn-user-upload/60eed95afba7-20251203.png)

そこで今回の手法では、以下の二段階に分けて計算を進めます。

1. **チェッカー状にピクセルを間引き、まずは半分だけレイマーチングを実行する。**
   - 穴あきのスカスカ画像が得られるが、各ピクセルのヒット点がスレッドグループ内に分散します。
   - この段階で得られるヒット点を次の初期開始位置のヒントとします。
2. **スレッドグループ全体で同期し、共有メモリにヒット点情報を集約する。**
   - 近傍ピクセルの結果を互いに参照できるようにします。
   - HLSLでバリアをするには `GroupMemoryBarrierWithGroupSync()` が使えます。
3. **まだ計算していないピクセルに対して、周囲のヒット点を起点にレイを再開する**
    - レイのスタート位置を物体表面の近くに寄せられるため、最大ステップ数を大きく減らしても収束しやすくなります。
    - 無駄な空間探索が削減されて収束しやすくなり、計算時間をかなり削減できます。

このようなスレッドグループ全体で情報を共有しながら探索する方式を実装してみました。二段目のレイマーチングの最大ステップ数を16分の1に減らしてみたところ、レイマーチングを1.5~1.7倍高速化することが出来ました。ただし、この手法は必ずしも優れているというわけではないということに注意してください。最大ステップ数を大きく減らすため、収束しない場合にチェッカー上のノイズが紛れ込んでしまう可能性があります。また、スレッドグループで描画するタイルの境界部分について開始点周りのヒントが2、3ピクセル分しか得られないためタイリングアーティファクトが発生することもあります。

![](https://storage.googleapis.com/zenn-user-upload/cc9b00b5eddc-20251203.png)



------

## 8. まとめ

本記事では、ラスタライズ方式とレイマーチング方式を組み合わせたハイブリッド描画手法について紹介しました。レイマーチングは一般に計算負荷が高いものの、アップスケーリング技術などを取り入れることで、ゲームでも十分に実用的なレベルへ近づけることができそうです。SDF を用いることで、ポリゴンでは難しい造形を柔軟に表現できる点は大きな魅力ではないでしょうか。本記事が何らかの参考になれば幸いです。

蛇足ですが、本記事上のゲームのリポジトリはこちらになります。

https://github.com/sashi0034/F0V2

実はグラフィックだけでなく衝突判定といった物理部分やゲームAIも自作しているので、そのあたりについてもいずれご紹介できればと思います。




## 参考文献・サイトなど



[^ac6]: 『ARMORED CORE VI FIRES OF RUBICON』メイキングセミナー – ゲーム制作ワークフローセミナー第7弾 (https://www.too.com/dc/report/2401_armored_core_vi_making_seminar/)
[^shadertoy]: Shadertoy (https://www.shadertoy.com/)
[^ps5-pro]:  PS5 Pro Technical Seminar at SIE HQ (https://www.youtube.com/watch?v=lXMwXJsMfIQ)
[^fsr1]: FidelityFX Super Resolution 1.0 (https://github.com/GPUOpen-Effects/FidelityFX-FSR)
[^smaa]: SMAA: Subpixel Morphological Antialiasing (https://github.com/iryoku/smaa)



