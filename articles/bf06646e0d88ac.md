---
title: "AngelScript を C++ プロジェクトに組み込む"
emoji: "🎑"
type: "tech" # tech: 技術記事 / idea: アイデア
topics:
  - "cpp"
  - "lua"
  - "c"
published: true
published_at: 2025-12-17 21:00
---

# 1. はじめに

以前も何度か AngelScript に関する記事を書いたのですが、そういえば実際に C++ プロジェクトへ導入する方法を書いてなかったなと思い至ったので、自分の備忘録も兼ねて今回まとめてみようと思います。所々過去の記事内容と重複箇所があって恐縮ですが、改めて整理してみます。

# 2. AngelScript について

AngelScript は世にも珍しい**静的型付け組み込みスクリプト言語**です。知名度こそ高くないものの、20年前から現在に至るまで安定して開発が継続されています。

公式サイト[^official-angelcode] では AngelScript が次のように説明されています。

> The AngelCode Scripting Library, or AngelScript as it is also known, is an extremely flexible cross-platform scripting library designed to allow applications to extend their functionality through external scripts. It has been designed from the beginning to be an easy to use component, both for the application programmer and the script writer.
>
> Efforts have been made to let it call standard C functions and C++ methods with little to no need for proxy functions. The application simply registers the functions, objects, and methods that the scripts should be able to work with and nothing more has to be done with your code. The same functions used by the application internally can also be used by the scripting engine, which eliminates the need to duplicate functionality.
>
> For the script writer the scripting language follows the widely known syntax of C/C++, but without the need to worry about pointers and memory leaks. Contrary to most scripting languages, AngelScript uses the common C/C++ datatypes for more efficient communication with the host application.
>
> AngelScript is completely free, released under the zlib license. I only ask for your recognition, nothing else. However, if you would like to make a donation I would be very grateful. Your donation gives me more inspiration and will allow me to spend more time working with AngelScript.
>

まとめると:

- **C/C++ 関数やメソッドをほぼそのまま呼べる**。C++ 側は公開したい関数・型を登録するだけでOK

- 文法は C/C++ 風で扱いやすく、**メモリ安全**

- クロスプラットフォーム。zlib ライセンス

要するに、**C++と親和性の高く、C++に組み込みやすいスクリプト言語**となっています。

C++ と似た文法と書いてありますが、delegate や setter / getter のように C#-like な仕様も混ざっているのが特徴です。

# 3. なぜ組み込みスクリプト言語を導入するか

C++ プロジェクトにわざわざスクリプト言語を組み込むのはどうしてか、ということについて一応触れておこうと思います。

プロジェクトに複数の言語をむやみに持ち込むと、コードが複雑になり、デバッグ性も悪化してしまいます。

それでもなお C++ と組み込みスクリプト言語を併用するメリットは、次の三点に集約できるのではないでしょうか。

1. スクリプト言語はアセンブリ生成を伴うコンパイル工程を必要としない
   ➡️ コード変更を爆速で実行へ反映できる
   ➡️ ゲーム開発のように細かな調整作業が多いプロジェクトにおいて、**ホットリロードを活用することで開発イテレーションを速く出来る**。

   :::message

   Note:  C++ でもホットリロードを可能にするミドルウェア[^lpp]があるとはいえ、コードを変更してから実際に反映されるまでの時間はやはり圧倒的にスクリプト言語のほうが速いですね。

   :::



2. プログラムで調整作業が多い部分をスクリプト側へ切り出せる
   ➡️ 非エンジニアでも安全に調整可能な領域を設けられる
   ➡️ スクリプト言語は文法などが比較的簡単であり、**非エンジニアであっても調整が出来るようになる**[^ff7ec-lua]。



3. スクリプト側でアプリケーションの拡張を行うことが出来る

   ➡️**配布したアプリケーションをユーザー側でカスタマイズ出来る** (アドオンや MOD など)。

   :::message

   Note:  C++ でもDLL形式でアプリケーションのユーザー拡張が可能であるものの、手軽さの観点では圧倒的にスクリプト言語に分があります。

   :::

# 4. AngelScript と Lua を比較

組み込み言語をプロジェクトに導入するとなった時、多くの人は真っ先に Lua を思い浮かべると思います。

Lua は歴史が長く、長年にわたり利用されてきた背景には、以下に挙げるような長所があるのではないでしょうか。

- 軽量で動作が安定
- ユーザーが多く、ドキュメントやライブラリが豊富
- 構文がシンプルで、非エンジニアであっても取っつきやすい

一方、AngelScript は Lua よりも使用人口が圧倒的に少なく、構文もエンジニア向けです。

それでもあえてマイナーな AngelScript を採用する理由について、ここでは三つ挙げてみます。

## 4.1 静的型付けによる恩恵

さて、AngelScript のウリの一つは静的型付けです。

静的型付けのメリットはもはや周知の事実だと思うので、以下に生成AIによる文章を掲載しておきます。

> 🤖 静的型付けは、
>
> - (1) 型エラーをコンパイル時に検出でき、バグの早期発見につながる点
> - (2) 型情報を基に最適化が行われやすくパフォーマンス向上が期待できる点
> - (3) IDE 補完やリファクタリング支援が強力になり大規模開発での保守性が高まる点
>
> などが主要なメリットです。

どれも重要だと思いますが、特に (3) について、**オブジェクトのメンバ一覧が適切に補完される**という点は魅力的ではないでしょうか。Lua や Python といった動的型付けの言語では、オブジェクトのメンバ補完が弱くなりやすく、またメソッドに渡すべき引数の意図が把握しにくくなる印象が拭えません。

**スクリプトが静的型付けであれば IDE 支援が強力になります。C++ 側で型や関数を定義すると、AngelScript 側でも適切に補完候補に表示できます**。

![image-20251210171157611](/images/image-20251210145428836.png)

## 4.2 数値型の粒度が C++ 同等 (int8 ~ double)

JavaScript などでもそうなのですが、**Lua では整数も含めて全ての数値が double (FP64) 型で扱われます** (と認識していたのですが、改めて調べてみたところ、どうやら Lua 5.3[^lua5-3] から整数型が実装されていたようです)。

数値を汎用的に double で表現することは、処理系の構造を簡潔に保てるとともに、ユーザーに数値の型選択の負担を強いないという利点を持ちます。そのため、非プログラマにも易しい言語となりそうです。

確かに、double で全ての数値を表すことは理にかなった言語仕様だと思います。しかし、その言語を別のホスト言語に組み込んだときに少々厄介なことになります。

C++ に Lua を組み込む場合を考えてみましょう。Lua では全ての数値を double で扱うのに対し、C++ プロジェクトでは int や float が混在しています。すると、いくつか問題が顕在化します。

まず、**同じデータを扱う際に C++ と Lua で異なるデータ型を用いてしまうことで不整合が生じ、バグにつながる可能性があります**。具体例として、「ドラゴンクエストX」におけるオウムガイのサイズ誤判定バグ[^dq10-lua]が有名ではないでしょうか。概要をざっくりと説明すると、C++ 側のデータを Lua 側で復元する際に、Lua 側の計算過程において浮動小数点誤差の丸めがややこしい状況をもたらしていたようです (リンク先のスライドに興味深い説明が掲載されています)。

また、Lua から C++ の API を呼び出すたびに、double から別の数値型への変換コストが発生してしまうことも気になります (とはいえ、変換命令 (`CVTSS2SD` など) は数クロック内で完了するようなので、微々たるものではありますが...)。Lua の多重ループ内で C++ 関数を呼び出すときはパフォーマンスのボトルネックとなってしまうかもしれません。

一方、**AngelScript の場合、数値型を C++ 同等 int8~double で区別します**。整数型、浮動小数型に分かれていることはもちろん、数値幅を 8-bit, 16-bit, 32-bit, 64-bit で分類し、数値符号の有無まで区別します。これにより、C++ のデータを直接 AngelScript で扱うことが可能になり、上記で挙げた Lua のデメリットを回避出来ます。

> Integer: `int8`, `uint8`, `int16`, `uint16`, `int`, `uint`, `int64`, `uint64`
>
> Real: `float`, `double`

C++ と AngelScript で数値型を一対一対応することが出来るので、AngelScript から C++ 関数を呼び出す際はC++でラッパー関数を経由せずとも直接呼ぶことが可能です (「ネイティブ呼び出し」と言うようです)。



## 4.3 0-based indexing

Lua は 1-based indexing の言語[^one-based]です。つまり、配列の先頭要素へのアクセスは `array[0]` ではなく、`array[1]` とするように設計されています。これは、バグの温床になりやすいポイントだと思います。Lua と C++ を併用する場合、C++ では 0-based indexing なのにも関わらず、Lua では 1-based indexing です。異なる流派が同じプロジェクトに同居する呉越同舟状態となってしまい、プログラマの脳を非常に混乱させます。

一方、**AngelScript は 0-based indexing** であるため、配列アクセス問題で頭を悩ませる必要がありません。



# 5. C++ プロジェクトに AngelScript を組み込む

前置きが長々としてしまいましたが、本題に入っていきます。AngelScript を C++ プロジェクトに組み込んでいきます。

公式リポジトリから最新のリリースを取得します。以前は AngelScript のリポジトリが SourceForge に置かれていたのですが、つい最近 GitHub に移行したようです。

https://github.com/anjo76/angelscript

ダウンロードした AngelScript SDK をプロジェクトに追加します。

`sdk/angelscript`が AngelScript のコア部分ですが、多くの場合、`sdk/add_on` も使うことになると思います。add_on にはスクリプト用の文字列型や配列型といった AngelScript 標準のライブラリが入っています。

導入について、CMake プロジェクトで設定する場合、AI エージェントに任せて問題なさそうでした。

しかしながら、Windows / Visual Studio プロジェクトの場合、手動で GUI ポチポチする設定がややこしいと思われるので、以下に手順を掲載します。


::::details Visual Studio プロジェクトで AngelScript を導入する

1.  `angelscript\sdk\angelscript` をソリューション直下に配置

2. ソリューションエクスプローラーから「ソリューション」右クリック

3. 「追加」 ➡️ 「既存のプロジェクト」➡️ `angelscript/projects/msvc2022/angelscript.vcxproj` を追加

   (`2022` の部分は Visual Studio のバージョンに合わせて選ぶ)

![image-20251210172559784](/images/image-20251210171143947.png)

4. ソリューションエクスプローラーから '自分のプロジェクト名' を右クリック
5. 「追加」➡️「参照」➡️angelscript にチェックを入れて OK

![image-20251210172804915](/images/image-20251210172804915.png)

![image-20251210172846492](/images/image-20251210172846492.png)

6. ソリューションエクスプローラーから '自分のプロジェクト名' を右クリック ➡️プロパティ
7. 構成プロパティ ➡️ C/C++ ➡️全般 ➡️「追加のインクルードディレクトリ」を編集し、自分のプロジェクトから angelscript/include までのパスを入力する (今回は `../angelscript/include`)。

![image-20251210173706977](/images/image-20251210173134444.png)

以上で、AngelScript 自体のプロジェクト設定は終わりです。

以下のコードでビルドが通るか試してみましょう。

```cpp
#include <cassert>
#include <iostream>

#include "angelscript.h"

int main(int argc, char** argv)
{
    asIScriptEngine* engine = asCreateScriptEngine();
    assert(engine != nullptr);

    engine->ShutDownAndRelease();

    std::cout << "AngelScript engine created and released successfully." << std::endl;

    return 0;
}
```



:::message

補足: よくあるコンパイルエラー

>   'RuntimeLibrary' の不一致が検出されました。値 'MTd_StaticDebug' が MDd_DynamicDebug の値 'main.obj' と一致しません。

解決策: プロジェクトのプロパティ > `構成プロパティ` / `C/C++` / `ランタイムライブラリ` を変える。今回の場合、デバッグビルドなら「マルチスレッド デバッグ (/MTd)」、リリースビルドなら「マルチスレッド (/MT)」にする。

:::



次に、SDK に含まれている `sdk/add_on` もプロジェクトに追加しておきます。上述の通り、add_on には文字列型や配列型といった AngelScript 標準のライブラリが入っています。

ここでは、`sdk/add_on` を自分のプロジェクトのほうに組み込みます。add_on 内のファイルを全部プロジェクトに追加してしまってよいのですが、`sdk/add_on/autowrapper/generator` は単体で用いるためのプロジェクトになっているので、これだけ除外しておいてください。

add_on 内は unsafe な関数を使っている箇所があるので、ビルドすると "This function or variable may be unsafe. To disable deprecation, use _CRT_SECURE_NO_WARNINGS "というエラーが出る場合があります。その場合は「プリプロセッサ」で `_CRT_SECURE_NO_WARNINGS ` を書いておけばビルドは通るようになります。

![image-20251210174627266](/images/image-20251210174627266.png)

::::



本記事のために作った Visual Studio プロジェクトは以下のリポジトリに置きました。

https://github.com/sashi0034/AngelScriptMinimalExample



## 6. チュートリアルの動作確認

### 6.1 チュートリアル

公式チュートリアル[^official-tutorial] を実行してみます。

```cpp
#include <cassert>
#include <cstdio>

#include "angelscript.h"
#include "add_on/scriptbuilder/scriptbuilder.h"
#include "add_on/scriptstdstring/scriptstdstring.h"

// メッセージコールバック
void MessageCallback(const asSMessageInfo* msg, void* param)
{
    const char* type = "ERR ";
    if (msg->type == asMSGTYPE_WARNING) type = "WARN";
    else if (msg->type == asMSGTYPE_INFORMATION) type = "INFO";

    printf("%s (%d, %d) : %s : %s\n", msg->section, msg->row, msg->col, type, msg->message);
}

// C++ から呼ばれる関数
void print(const std::string& msg)
{
    printf("%s", msg.c_str());
}

int main(int argc, char** argv)
{
    // エンジン生成
    asIScriptEngine* engine = asCreateScriptEngine();
    assert(engine != nullptr);

    // メッセージコールバック登録
    int r = engine->SetMessageCallback(asFUNCTION(MessageCallback), 0, asCALL_CDECL);
    assert(r >= 0);

    // 標準文字列型を登録
    RegisterStdString(engine);

    // グローバル関数 print() を登録
    r = engine->RegisterGlobalFunction("void print(const string &in)", asFUNCTION(print), asCALL_CDECL);
    assert(r >= 0);

    // スクリプトビルダーでモジュール作成
    CScriptBuilder builder;
    r = builder.StartNewModule(engine, "MyModule");
    if (r < 0)
    {
        printf("Failed to start module\n");
        return -1;
    }

    // -----------------------------------------------
    // スクリプトをセクションとして追加
    const char* script = R"(
        void as_main()
        {
            print("Hello world\n");
        }
)";
    // -----------------------------------------------

    r = builder.AddSectionFromMemory("my_script.as", script);
    if (r < 0)
    {
        printf("Failed to add script section\n");
        return -1;
    }

    r = builder.BuildModule();
    if (r < 0)
    {
        printf("Failed to build module\n");
        return -1;
    }

    // モジュール取得
    asIScriptModule* mod = engine->GetModule("MyModule");
    if (!mod)
    {
        printf("Module not found\n");
        return -1;
    }

    // 関数取得
    asIScriptFunction* func = mod->GetFunctionByDecl("void as_main()");
    if (!func)
    {
        printf("Function 'void as_main()' not found\n");
        return -1;
    }

    // コンテキスト作成・準備・実行
    asIScriptContext* ctx = engine->CreateContext();
    ctx->Prepare(func);
    r = ctx->Execute();
    if (r != asEXECUTION_FINISHED)
    {
        if (r == asEXECUTION_EXCEPTION)
        {
            printf("Exception: %s\n", ctx->GetExceptionString());
        }
    }

    // クリーンアップ
    ctx->Release();
    engine->ShutDownAndRelease();

    return 0;
}

```

実行すると、`Hello world` が表示されました。



### 6.2 スクリプト部分を別ファイルに抽出

前節では、スクリプト部分を以下のようにハードコーディングしていました。

```cpp
// main.cpp
const char* script = R"(
        void as_main()
        {
            print("Hello world\n");
        }
)";
r = builder.AddSectionFromMemory("my_script.as", script);
```

この `script` をスクリプトファイル `my_script/script.as` として分離してみましょう。

```diff
  your_project/
  ├─ main.cpp
+ └─ my_script/
+    └─ my_script.as
```

```diff cpp
// main.cpp
- const char* script = R"(
-         void as_main()
-         {
-             print("Hello world\n");
-         }
- )";
- r = builder.AddSectionFromMemory("my_script.as", script);

+ r = builder.AddSectionFromFile("my_script/my_script.as");
```

```cs
// my_script/my_script.as
void main()
{
    print("Hello world\n");
}
```

以上で、スクリプト部分を別ファイルに分離することが出来ました。



# 7. asbind20 を導入し、バインドを簡単にしてみる

C++ アプリケーションの型や関数を AngelScript で使えるようにバインドしてみます。

公式ページ[^doc-register-func]には以下の例が示されています。

```cpp
// file.cpp
class Object
{
  // Class method
  void method();

  // Overloaded method
  void method2(int input);
  void method2(int input, int &output);

  // Const method
  int getAttr(int) const;
};

// Registering the class method
r = engine->RegisterObjectMethod("object", "void method()", asMETHOD(Object,method), asCALL_THISCALL); assert( r >= 0 );

// Registering the overloaded methods
r = engine->RegisterObjectMethod("object", "void method2(int)", asMETHODPR(Object, method2, (int), void), asCALL_THISCALL); assert( r >= 0 );
r = engine->RegisterObjectMethod("object", "void method2(int, int &out)", asMETHODPR(Object, method2, (int, int&), void), asCALL_THISCALL); assert( r >= 0 );

// Registering a const method
r = engine->RegisterObjectMethod("object", "int getAttr(int) const", asMETHODPR(Object, getAttr, (int) const, int), asCALL_THISCALL); assert( r >= 0 );
```

この通りにバインド作業に取り組むのが通常の方法なのですが、いささか冗長感があるのは否めません。



そこで、本記事では **asbind20** というライブラリを使ってバインドをやってみます。

**asbind20 は C++20 向けのヘッダオンリライブラリです**。バインド用のコードがモダンで簡潔に書くことが出来ます。



https://github.com/HenryAWE/asbind20



例として、以下のC++ で定義する型に対して asbind20 を使ってみます。

```cpp
    struct Vector3
    {
        float x, y, z;
    };

    struct FlagAndVector3
    {
        bool flag;
        Vector3 vec;

        operator bool() const
        {
            return flag;
        }

        float manhattan() const
        {
            return vec.x + vec.y + vec.z;
        }
    };
```

これらは以下のようにバインド出来ます。

```cpp
asbind20::value_class<Vector3>(engine, "Vector3", asOBJ_APP_CLASS_ALLFLOATS)
    .behaviours_by_traits() // デフォルトの CTOR, DTOR などを自動登録
    .property("float x", &Vector3::x) // メンバ x の登録
    .property("float y", &Vector3::y)
    .property("float z", &Vector3::z)
    .opEquals(); // operator== の登録

asbind20::value_class<FlagAndVector3>(engine, "FlagAndVector3")
    .behaviours_by_traits() // デフォルトの CTOR, DTOR などを自動登録
    .constructor<bool>("bool flag") // 引数付き CTOR の登録
    .property("bool flag", &FlagAndVector3::flag)
    .property("Vector3 vec", &FlagAndVector3::vec)
    .method("float manhattan() const", &FlagAndVector3::manhattan)
    .opEquals() // operator== の登録
    .opConv<bool>() // operator bool の登録
    .opImplConv<bool>(); // operator bool の登録 (暗黙の型変換用)
```

最初に紹介したバインド実装と比べると、かなりシンプルになりました。

実際にプログラムを動作させてみましょう。サンプルコードを以下に掲載します 。フォルダ構成は先程と同様です。



```cpp
// main.cpp
#include <iostream>

#include "add_on/scriptarray/scriptarray.h"
#include "add_on/scriptstdstring/scriptstdstring.h"
#include "add_on/datetime/datetime.h"
#include "add_on/scriptbuilder/scriptbuilder.h"
#include "add_on/scriptfile/scriptfile.h"
#include "asbind20/bind.hpp"
#include "asbind20/invoke.hpp"

namespace
{
    void MessageCallback(const asSMessageInfo* msg, void* param)
    {
        auto type = "[error]";
        if (msg->type == asMSGTYPE_WARNING)
            type = "[warn] ";
        else if (msg->type == asMSGTYPE_INFORMATION)
            type = "[info] ";

        const auto message = std::format("{} {}({},{}) {}", type, msg->section, msg->row, msg->col, msg->message);
        if (msg->type == asMSGTYPE_INFORMATION)
        {
            std::cout << message << std::endl;
        }
        else
        {
            std::cerr << message << std::endl;
        }
    }

    void script_print(const std::string& message)
    {
        printf("%s", message.c_str());
    }

    void script_println(const std::string& message)
    {
        printf("%s\n", message.c_str());
    }

    struct Vector3
    {
        float x, y, z;

        bool operator==(const Vector3&) const = default;
    };

    struct FlagAndVector3
    {
        bool flag;
        Vector3 vec;

        FlagAndVector3() = default;

        FlagAndVector3(bool flag) : flag(flag), vec{0.0f, 0.0f, 0.0f}
        {
        }

        bool operator==(const FlagAndVector3&) const = default;

        operator bool() const
        {
            return flag;
        }

        float manhattan() const
        {
            return vec.x + vec.y + vec.z;
        }
    };

    class GameObject
    {
    private:
        int m_refCount{1};

    public:
        FlagAndVector3 someData{};

        GameObject()
        {
            std::cout << "GameObject: ctor()" << std::endl;
        }

        bool equalsTo(const GameObject& other) const
        {
            return someData == other.someData;
        }

        void addRef()
        {
            ++m_refCount;
            std::cout << "GameObject: addRef(): " << m_refCount << std::endl;
        }

        void release()
        {
            std::cout << "GameObject: release(): " << m_refCount << std::endl;

            if (--m_refCount == 0)
            {
                std::cout << "GameObject: delete!" << std::endl;
                delete this;
            }
        }

        ~GameObject()
        {
            std::cout << "GameObject: dtor()" << std::endl;
        }
    };

    // C++ の型や関数を AngelScript に登録する
    void registerEngine(const asbind20::script_engine& engine)
    {
        RegisterStdString(engine);
        RegisterScriptArray(engine, true);

        // -----------------------------------------------
        // asbind20 を使用して型や関数を登録する

        asbind20::global(engine)
            .message_callback(&MessageCallback)
            .function("void print(const string& in message)", &script_print) // グローバル関数登録
            .function("void println(const string& in message)", &script_println);

        // 値型の登録: value_class<>
        asbind20::value_class<Vector3>(engine, "Vector3", asOBJ_APP_CLASS_ALLFLOATS)
            .behaviours_by_traits() // デフォルトの CTOR, DTOR などを自動登録
            .property("float x", &Vector3::x) // メンバ x の登録
            .property("float y", &Vector3::y)
            .property("float z", &Vector3::z)
            .opEquals(); // operator== の登録

        asbind20::value_class<FlagAndVector3>(engine, "FlagAndVector3")
            .behaviours_by_traits() // デフォルトの CTOR, DTOR などを自動登録
            .constructor<bool>("bool flag") // 引数付き CTOR の登録
            .property("bool flag", &FlagAndVector3::flag)
            .property("Vector3 vec", &FlagAndVector3::vec)
            .method("float manhattan() const", &FlagAndVector3::manhattan)
            .opEquals() // operator== の登録
            .opConv<bool>() // operator bool の登録
            .opImplConv<bool>(); // operator bool の登録 (暗黙の型変換用)

        // 参照型の登録: ref_class<>
        asbind20::ref_class<GameObject>(engine, "GameObject")
            .default_factory() // デフォルトの CTOR を登録
            .addref(&GameObject::addRef) // 参照カウンタ制御関数の登録
            .release(&GameObject::release) // 参照カウンタ制御関数の登録
            .property("FlagAndVector3 someData", &GameObject::someData)
            .method("bool equalsTo(const GameObject& in other) const", &GameObject::equalsTo);
    }
}

int main()
{
    const auto engine = asbind20::make_script_engine();

    registerEngine(engine);

    CScriptBuilder builder{};

    std::string moduleName{"my_script/my_script.as"};

    int r;
    r = builder.StartNewModule(engine, moduleName.c_str());
    assert(r >= 0);

    r = builder.AddSectionFromFile(moduleName.c_str());
    assert(r >=0);

    r = builder.BuildModule();
    assert(r >= 0);

    asIScriptModule* module = engine->GetModule(moduleName.c_str());
    assert(module != nullptr);

    const asbind20::request_context ctx{engine};

    FlagAndVector3 arg0;
    arg0.flag = true;
    arg0.vec = {1.0f, 2.0f, 3.0f};

    GameObject arg1;
    arg1.someData = arg0;

    // my_script.as で定義された as_main を取得する
    asIScriptFunction* func =
        module->GetFunctionByDecl("float as_main(FlagAndVector3 value, GameObject& obj)");

    // 引数を渡して実行する
    const auto result = asbind20::script_invoke<float>(ctx, func, arg0, &arg1);
    if (result.has_value())
    {
        std::cout << "C++: result: " << result.value() << std::endl;
    }
    else
    {
        std::cerr << "Failed to execute the script: " << result.error() << std::endl;
    }

    module->Discard();
}

```

スクリプト側は以下の通りです。

```cs
// my_script/my_script.as
class GameObjectWrapper {
    // '@' でオブジェクト参照を保持するハンドルを定義出来る (value_class で定義されたクラスは不可)
    GameObject@ obj = null;

    void isSame(const GameObject& in other) {
        if (@obj != null && obj.equalsTo(other)) {
            println("AS: GameObjectWrapper: obj.equalsTo(other): true");
        } else {
            println("AS: GameObjectWrapper: obj.equalsTo(other): false");
        }
    }
}

// C++ 側から呼び出されるエントリポイント
float as_main(FlagAndVector3 value, GameObject& obj) {
    const float result = value.manhattan();
    println("AS: value.manhattan(): " + result);

    if (value.flag) {
        println("AS: value.flag: true");
    } else {
        println("AS: value.flag: false");
    }

    const bool f = value // <-- FlagAndVector3 の operator bool() が呼ばれる
        && value.flag;
    println("AS: value && value.flag: " + f); // <-- 同じものを && しており、そりゃ true になる

    // -----------------------------------------------

    GameObjectWrapper wrapper;
    wrapper.isSame(obj); // <-- false

    // ハンドルの代入 (参照の付け替え)
    @wrapper.obj = @obj;
    wrapper.isSame(obj); // <-- true

    @wrapper.obj = @GameObject();
    wrapper.isSame(obj); // <-- false

    // -----------------------------------------------

    return value.manhattan();
}

```

:::details 実行結果

```
GameObject: ctor()
AS: value.manhattan(): 6
AS: value.flag: true
AS: value && value.flag: true
AS: GameObjectWrapper: obj.equalsTo(other): false
GameObject: addRef(): 2
GameObject: addRef(): 3
GameObject: release(): 3
GameObject: addRef(): 3
GameObject: release(): 3
AS: GameObjectWrapper: obj.equalsTo(other): true
GameObject: ctor()
GameObject: release(): 2
GameObject: addRef(): 2
GameObject: release(): 2
GameObject: addRef(): 2
GameObject: release(): 2
AS: GameObjectWrapper: obj.equalsTo(other): false
GameObject: release(): 1
GameObject: delete!
GameObject: dtor()
C++: result: 6
GameObject: dtor()
GameObject: ctor()
AS: value.manhattan(): 6
AS: value.flag: true
AS: value && value.flag: true
AS: GameObjectWrapper: obj.equalsTo(other): false
GameObject: addRef(): 2
GameObject: addRef(): 3
GameObject: release(): 3
GameObject: addRef(): 3
GameObject: release(): 3
AS: GameObjectWrapper: obj.equalsTo(other): true
GameObject: ctor()
GameObject: release(): 2
GameObject: addRef(): 2
GameObject: release(): 2
GameObject: addRef(): 2
GameObject: release(): 2
AS: GameObjectWrapper: obj.equalsTo(other): false
GameObject: release(): 1
GameObject: delete!
GameObject: dtor()
C++: result: 6
GameObject: dtor()
```

:::

(情報を詰め込んでいったら思ったよりもコードが長くなってしまいました、すいません)

コード内でいくつか重要な点があるので補足します。

- `value_class` と `ref_class` で型登録

  最初の例では型の登録を `value_class` で行いました。型のメンバがすべて値型として完結しているのであれば、基本的に `value_class` を使います。`value_class` で登録した型は、スクリプト内でも値型として扱われます。`value_class` はスクリプト内でハンドルとして扱うことは出来ません。

  一方、型の登録は `value_class` だけでなく、 `ref_class` で登録することも出来ます。**`ref_class` で型を登録した場合は、スクリプト内でハンドル `Type@` として所持出来ます**。ハンドルは、一般的なオブジェクト指向言語におけるオブジェクト参照と同じ概念です。`ref_class` で登録する場合、`addref`と `release` によって参照カウンタの管理が出来ます。生成時の参照カウンタは 1 であり、ハンドルが共有されると `addRef` によって増加し、ハンドルが破棄されると `release` によって減少し、0 になったタイミングでオブジェクトは破棄されます。これは、shared_ptr のようにポインタ側で参照カウンタを管理するスタイルではなく、COM オブジェクトのようにオブジェクト側で参照カウンタを管理する方式となっています。

  ここで留意しておきたいのは、登録したい型のメンバに他オブジェクトへの参照がある場合でも `value_class` にするときがあることです。例えば、次の型 `MyObj` は value_class で登録することが出来ます。参照カウント管理が `MyObj` のコピー・代入・破棄操作に内包されているからですね。

    ```cpp
    // file.cpp
    class MyObj {
        class Impl;

        std::shared_ptr<Impl> pImpl;
    }
    ```

​	このあたりの型登録については Siv3D 内部コードの `Siv3D/Script/Bind/ScriptTypes.cpp` が参考になりそうです。

https://github.com/Siv3D/OpenSiv3D/blob/8458f3d8d5b974eeabbc6c3824d4648b48bf0cfa/Siv3D/src/Siv3D/Script/Bind/ScriptTypes.cpp



- 型登録の際のオプション

  通常のバインド作業は、型の登録の際に多くのフラグを指定する必要があります。これは、AngelScript 側でオブジェクトを適切に管理するために必要なものです。asbind20 では、C++20 メタプログラミングを駆使してその多くのフラグ指定を自動でやってくれます。しかしながら、先程のコード例 `value_class<Vector3>(engine, "Vector3", asOBJ_APP_CLASS_ALLFLOATS)` における `asOBJ_APP_CLASS_ALLFLOATS` のように、**いくつかのフラグについては手動で設定する必要があります**。それについては、asbind20 のドキュメントに詳しく書いてあります。



https://asbind20.readthedocs.io/en/latest/object_type.html#flags-of-value-type



# 8. AngelScript コーディング環境を整備する

実際のプロジェクトで AngelScript を運用する場合を想定し、コーディング環境を VSCode 上で構築していきます。

1. VSCode のマーケットプレイスから「AngelScript Language Server」をインストールします。

   手前味噌で恐縮ですが、この拡張機能を導入することで AngelScript のシンボル定義へのジャンプや参照検索、コード補完に加えて、型チェックや関数呼び出し時の引数チェックなどが出来ます。

![image-20251214150210609](/images/image-20251214150210609.png)

2. スクリプトが入ったディレクトリの直下に `as.predefined` というファイルを作成します。

   `as.predefined` は AngelScript Language Server 用の設定ファイルです。

   AngelScript Language Server が `*.as`を解析するとき、親ディレクトリを遡って `as.predefined`を探索します。

   ```diff
   your_project/
   ├─ main.cpp
   └─ my_script/
   +  ├─ as.predefined
      └─ my_script.as
   ```

   ![image-20251214151210550](/images/image-20251214151210550.png)

3. `as.predefined` に C++ 側で定義した関数を書きます。

   今回は、先程の例に合わせて以下のようにします。

   ```cs
   class Vector3 {
       float x, y, z;
   }

   class FlagAndVector3 {
       FlagAndVector3();
       FlagAndVector3(bool flag);

       bool flag;
       Vector3 vec;

       float manhattan() const;

       bool opConv() const;
       bool opImplConv() const;
   }

   class GameObject {
       FlagAndVector3 someData;

       bool equalsTo(const GameObject& in other) const;
   }

   class string {
    string(const string&in);
    string opAdd(?) const;
    string opAdd_r(?) const;
       // ...
   }

   void println(const string& in msg);
   ```

   `as.predefined` は手動で書いていくことも出来ますが、多くの場合、以下のファイルのように C++ 側で自動生成も出来ます。アプリケーション起動時に自動生成するようにしておくと便利です。



https://github.com/sashi0034/angel-lsp/blob/HEAD/examples/generate_as_predefined.cpp



4. `my_script.as` を開けて、実際にコーディングしてみます。

   すると、C++ 側で定義した型や関数が補完候補に挙がってきました。`as.predefined` で定義した内容が反映されていることが分かります。

   ![image-20251214152435518](/images/image-20251214152435518.png)



このように、AngelScript のコーディング作業において、C++ で定義した型や関数が適切に連携されるのは大きな強みではないでしょうか。

# おわりに

本記事では asbind20 を試しつつ、実際のプロジェクトで AngelScript 環境を構築する手順について紹介しました。

AngelScript の文法などにはあまり踏み込めていないので、折を見てまた紹介出来たらと思います。



[^official-angelcode]: AngelCode.com (https://www.angelcode.com/)

[^ff7ec-lua]: Unity C#の関数を誰でも扱えるように。『FF7EC』におけるスクリプト言語「Lua」活用テクニック【CAGC2024】(↩https://gamemakers.jp/article/2024_03_22_63130/)
[^lpp]: C++ ゲーム開発者は Live++ を使おう (https://zenn.dev/sashi0034/articles/0f0416c8ee33c1)
[^lua5-3]: Luaの数値型 (https://zenn.dev/mod_poppo/articles/lua-number-types)
[^dq10-lua]:  ドラゴンクエストXを支える失敗事例 (3/3) (https://www.slideshare.net/slideshow/15a1x/132692354)
[^one-based]: 他にも Fortran や R, MATLAB, Julia といった科学技術計算系の言語では 1-based indexing が主流ですね。
[^official-tutorial]: 	AngelScript: Your First Script (https://www.angelcode.com/angelscript/sdk/docs/manual/doc_hello_world.html)
[^doc-register-func]: AngelScript: Registering a function (https://www.angelcode.com/angelscript/sdk/docs/manual/doc_register_func.html)
